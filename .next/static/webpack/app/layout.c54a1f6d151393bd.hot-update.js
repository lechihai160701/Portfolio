"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"f6c9aa1ef45e\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzP2IzMTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmNmM5YWExZWY0NWVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/SplashCursor.tsx":
/*!*************************************!*\
  !*** ./components/SplashCursor.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SplashCursor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction pointerPrototype() {\n    return {\n        id: -1,\n        texcoordX: 0,\n        texcoordY: 0,\n        prevTexcoordX: 0,\n        prevTexcoordY: 0,\n        deltaX: 0,\n        deltaY: 0,\n        down: false,\n        moved: false,\n        color: {\n            r: 0,\n            g: 0,\n            b: 0\n        }\n    };\n}\nfunction SplashCursor(param) {\n    let { SIM_RESOLUTION = 128, DYE_RESOLUTION = 1440, CAPTURE_RESOLUTION = 512, DENSITY_DISSIPATION = 3.5, VELOCITY_DISSIPATION = 2, PRESSURE = 0.1, PRESSURE_ITERATIONS = 20, CURL = 3, SPLAT_RADIUS = 0.2, SPLAT_FORCE = 6000, SHADING = true, COLOR_UPDATE_SPEED = 10, BACK_COLOR = {\n        r: 0.5,\n        g: 0,\n        b: 0\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        let pointers = [\n            pointerPrototype()\n        ];\n        let config = {\n            SIM_RESOLUTION: SIM_RESOLUTION,\n            DYE_RESOLUTION: DYE_RESOLUTION,\n            CAPTURE_RESOLUTION: CAPTURE_RESOLUTION,\n            DENSITY_DISSIPATION: DENSITY_DISSIPATION,\n            VELOCITY_DISSIPATION: VELOCITY_DISSIPATION,\n            PRESSURE: PRESSURE,\n            PRESSURE_ITERATIONS: PRESSURE_ITERATIONS,\n            CURL: CURL,\n            SPLAT_RADIUS: SPLAT_RADIUS,\n            SPLAT_FORCE: SPLAT_FORCE,\n            SHADING,\n            COLOR_UPDATE_SPEED: COLOR_UPDATE_SPEED,\n            PAUSED: false,\n            BACK_COLOR,\n            TRANSPARENT\n        };\n        const { gl, ext } = getWebGLContext(canvas);\n        if (!gl || !ext) return;\n        if (!ext.supportLinearFiltering) {\n            config.DYE_RESOLUTION = 256;\n            config.SHADING = false;\n        }\n        function getWebGLContext(canvas) {\n            const params = {\n                alpha: true,\n                depth: false,\n                stencil: false,\n                antialias: false,\n                preserveDrawingBuffer: false\n            };\n            let gl = canvas.getContext(\"webgl2\", params);\n            if (!gl) {\n                gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n            }\n            if (!gl) {\n                throw new Error(\"Unable to initialize WebGL.\");\n            }\n            const isWebGL2 = \"drawBuffers\" in gl;\n            let supportLinearFiltering = false;\n            let halfFloat = null;\n            if (isWebGL2) {\n                gl.getExtension(\"EXT_color_buffer_float\");\n                supportLinearFiltering = !!gl.getExtension(\"OES_texture_float_linear\");\n            } else {\n                halfFloat = gl.getExtension(\"OES_texture_half_float\");\n                supportLinearFiltering = !!gl.getExtension(\"OES_texture_half_float_linear\");\n            }\n            gl.clearColor(0, 0, 0, 1);\n            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES || 0;\n            let formatRGBA;\n            let formatRG;\n            let formatR;\n            if (isWebGL2) {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n            } else {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n            }\n            return {\n                gl,\n                ext: {\n                    formatRGBA,\n                    formatRG,\n                    formatR,\n                    halfFloatTexType,\n                    supportLinearFiltering\n                }\n            };\n        }\n        function getSupportedFormat(gl, internalFormat, format, type) {\n            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n                if (\"drawBuffers\" in gl) {\n                    const gl2 = gl;\n                    switch(internalFormat){\n                        case gl2.R16F:\n                            return getSupportedFormat(gl2, gl2.RG16F, gl2.RG, type);\n                        case gl2.RG16F:\n                            return getSupportedFormat(gl2, gl2.RGBA16F, gl2.RGBA, type);\n                        default:\n                            return null;\n                    }\n                }\n                return null;\n            }\n            return {\n                internalFormat,\n                format\n            };\n        }\n        function supportRenderTextureFormat(gl, internalFormat, format, type) {\n            const texture = gl.createTexture();\n            if (!texture) return false;\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            if (!fbo) return false;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            return status === gl.FRAMEBUFFER_COMPLETE;\n        }\n        function hashCode(s) {\n            if (!s.length) return 0;\n            let hash = 0;\n            for(let i = 0; i < s.length; i++){\n                hash = (hash << 5) - hash + s.charCodeAt(i);\n                hash |= 0;\n            }\n            return hash;\n        }\n        function addKeywords(source, keywords) {\n            if (!keywords) return source;\n            let keywordsString = \"\";\n            for (const keyword of keywords){\n                keywordsString += \"#define \".concat(keyword, \"\\n\");\n            }\n            return keywordsString + source;\n        }\n        function compileShader(type, source) {\n            let keywords = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n            const shaderSource = addKeywords(source, keywords);\n            const shader = gl.createShader(type);\n            if (!shader) return null;\n            gl.shaderSource(shader, shaderSource);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.trace(gl.getShaderInfoLog(shader));\n            }\n            return shader;\n        }\n        function createProgram(vertexShader, fragmentShader) {\n            if (!vertexShader || !fragmentShader) return null;\n            const program = gl.createProgram();\n            if (!program) return null;\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                console.trace(gl.getProgramInfoLog(program));\n            }\n            return program;\n        }\n        function getUniforms(program) {\n            let uniforms = {};\n            const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for(let i = 0; i < uniformCount; i++){\n                const uniformInfo = gl.getActiveUniform(program, i);\n                if (uniformInfo) {\n                    uniforms[uniformInfo.name] = gl.getUniformLocation(program, uniformInfo.name);\n                }\n            }\n            return uniforms;\n        }\n        class Program {\n            bind() {\n                if (this.program) gl.useProgram(this.program);\n            }\n            constructor(vertexShader, fragmentShader){\n                this.program = createProgram(vertexShader, fragmentShader);\n                this.uniforms = this.program ? getUniforms(this.program) : {};\n            }\n        }\n        class Material {\n            setKeywords(keywords) {\n                let hash = 0;\n                for (const kw of keywords){\n                    hash += hashCode(kw);\n                }\n                let program = this.programs[hash];\n                if (program == null) {\n                    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n                    program = createProgram(this.vertexShader, fragmentShader);\n                    this.programs[hash] = program;\n                }\n                if (program === this.activeProgram) return;\n                if (program) {\n                    this.uniforms = getUniforms(program);\n                }\n                this.activeProgram = program;\n            }\n            bind() {\n                if (this.activeProgram) {\n                    gl.useProgram(this.activeProgram);\n                }\n            }\n            constructor(vertexShader, fragmentShaderSource){\n                this.vertexShader = vertexShader;\n                this.fragmentShaderSource = fragmentShaderSource;\n                this.programs = {};\n                this.activeProgram = null;\n                this.uniforms = {};\n            }\n        }\n        const baseVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n      precision highp float;\\n      attribute vec2 aPosition;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform vec2 texelSize;\\n\\n      void main () {\\n        vUv = aPosition * 0.5 + 0.5;\\n        vL = vUv - vec2(texelSize.x, 0.0);\\n        vR = vUv + vec2(texelSize.x, 0.0);\\n        vT = vUv + vec2(0.0, texelSize.y);\\n        vB = vUv - vec2(0.0, texelSize.y);\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n      }\\n    \");\n        const copyShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      uniform sampler2D uTexture;\\n\\n      void main () {\\n          gl_FragColor = texture2D(uTexture, vUv);\\n      }\\n    \");\n        const clearShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      uniform sampler2D uTexture;\\n      uniform float value;\\n\\n      void main () {\\n          gl_FragColor = value * texture2D(uTexture, vUv);\\n      }\\n    \");\n        const displayShaderSource = \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uTexture;\\n      uniform sampler2D uDithering;\\n      uniform vec2 ditherScale;\\n      uniform vec2 texelSize;\\n\\n      vec3 linearToGamma (vec3 color) {\\n          color = max(color, vec3(0));\\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n      }\\n\\n      void main () {\\n          vec3 c = texture2D(uTexture, vUv).rgb;\\n          #ifdef SHADING\\n              vec3 lc = texture2D(uTexture, vL).rgb;\\n              vec3 rc = texture2D(uTexture, vR).rgb;\\n              vec3 tc = texture2D(uTexture, vT).rgb;\\n              vec3 bc = texture2D(uTexture, vB).rgb;\\n\\n              float dx = length(rc) - length(lc);\\n              float dy = length(tc) - length(bc);\\n\\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n              vec3 l = vec3(0.0, 0.0, 1.0);\\n\\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n              c *= diffuse;\\n          #endif\\n\\n          float a = max(c.r, max(c.g, c.b));\\n          gl_FragColor = vec4(c, a);\\n      }\\n    \";\n        const splatShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      uniform sampler2D uTarget;\\n      uniform float aspectRatio;\\n      uniform vec3 color;\\n      uniform vec2 point;\\n      uniform float radius;\\n\\n      void main () {\\n          vec2 p = vUv - point.xy;\\n          p.x *= aspectRatio;\\n          vec3 splat = exp(-dot(p, p) / radius) * color;\\n          vec3 base = texture2D(uTarget, vUv).xyz;\\n          gl_FragColor = vec4(base + splat, 1.0);\\n      }\\n    \");\n        const advectionShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      uniform sampler2D uVelocity;\\n      uniform sampler2D uSource;\\n      uniform vec2 texelSize;\\n      uniform vec2 dyeTexelSize;\\n      uniform float dt;\\n      uniform float dissipation;\\n\\n      vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n          vec2 st = uv / tsize - 0.5;\\n          vec2 iuv = floor(st);\\n          vec2 fuv = fract(st);\\n\\n          vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n          vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n          vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n          vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n\\n          return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n      }\\n\\n      void main () {\\n          #ifdef MANUAL_FILTERING\\n              vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n              vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n          #else\\n              vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n              vec4 result = texture2D(uSource, coord);\\n          #endif\\n          float decay = 1.0 + dissipation * dt;\\n          gl_FragColor = result / decay;\\n      }\\n    \", ext.supportLinearFiltering ? null : [\n            \"MANUAL_FILTERING\"\n        ]);\n        const divergenceShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uVelocity;\\n\\n      void main () {\\n          float L = texture2D(uVelocity, vL).x;\\n          float R = texture2D(uVelocity, vR).x;\\n          float T = texture2D(uVelocity, vT).y;\\n          float B = texture2D(uVelocity, vB).y;\\n\\n          vec2 C = texture2D(uVelocity, vUv).xy;\\n          if (vL.x < 0.0) { L = -C.x; }\\n          if (vR.x > 1.0) { R = -C.x; }\\n          if (vT.y > 1.0) { T = -C.y; }\\n          if (vB.y < 0.0) { B = -C.y; }\\n\\n          float div = 0.5 * (R - L + T - B);\\n          gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n      }\\n    \");\n        const curlShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uVelocity;\\n\\n      void main () {\\n          float L = texture2D(uVelocity, vL).y;\\n          float R = texture2D(uVelocity, vR).y;\\n          float T = texture2D(uVelocity, vT).x;\\n          float B = texture2D(uVelocity, vB).x;\\n          float vorticity = R - L - T + B;\\n          gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n      }\\n    \");\n        const vorticityShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uVelocity;\\n      uniform sampler2D uCurl;\\n      uniform float curl;\\n      uniform float dt;\\n\\n      void main () {\\n          float L = texture2D(uCurl, vL).x;\\n          float R = texture2D(uCurl, vR).x;\\n          float T = texture2D(uCurl, vT).x;\\n          float B = texture2D(uCurl, vB).x;\\n          float C = texture2D(uCurl, vUv).x;\\n\\n          vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n          force /= length(force) + 0.0001;\\n          force *= curl * C;\\n          force.y *= -1.0;\\n\\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\\n          velocity += force * dt;\\n          velocity = min(max(velocity, -1000.0), 1000.0);\\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\\n      }\\n    \");\n        const pressureShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uPressure;\\n      uniform sampler2D uDivergence;\\n\\n      void main () {\\n          float L = texture2D(uPressure, vL).x;\\n          float R = texture2D(uPressure, vR).x;\\n          float T = texture2D(uPressure, vT).x;\\n          float B = texture2D(uPressure, vB).x;\\n          float C = texture2D(uPressure, vUv).x;\\n          float divergence = texture2D(uDivergence, vUv).x;\\n          float pressure = (L + R + B + T - divergence) * 0.25;\\n          gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n      }\\n    \");\n        const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uPressure;\\n      uniform sampler2D uVelocity;\\n\\n      void main () {\\n          float L = texture2D(uPressure, vL).x;\\n          float R = texture2D(uPressure, vR).x;\\n          float T = texture2D(uPressure, vT).x;\\n          float B = texture2D(uPressure, vB).x;\\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\\n          velocity.xy -= vec2(R - L, T - B);\\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\\n      }\\n    \");\n        const blit = (()=>{\n            const buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n                -1,\n                -1,\n                -1,\n                1,\n                1,\n                1,\n                1,\n                -1\n            ]), gl.STATIC_DRAW);\n            const elemBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elemBuffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ]), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(0);\n            return function(target) {\n                let doClear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                if (!gl) return;\n                if (!target) {\n                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                } else {\n                    gl.viewport(0, 0, target.width, target.height);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n                }\n                if (doClear) {\n                    gl.clearColor(0, 0, 0, 1);\n                    gl.clear(gl.COLOR_BUFFER_BIT);\n                }\n                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n            };\n        })();\n        let dye;\n        let velocity;\n        let divergence;\n        let curl;\n        let pressure;\n        const copyProgram = new Program(baseVertexShader, copyShader);\n        const clearProgram = new Program(baseVertexShader, clearShader);\n        const splatProgram = new Program(baseVertexShader, splatShader);\n        const advectionProgram = new Program(baseVertexShader, advectionShader);\n        const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n        const curlProgram = new Program(baseVertexShader, curlShader);\n        const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n        const pressureProgram = new Program(baseVertexShader, pressureShader);\n        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n        const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n        function createFBO(w, h, internalFormat, format, type, param) {\n            gl.activeTexture(gl.TEXTURE0);\n            const texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, w, h);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            const texelSizeX = 1 / w;\n            const texelSizeY = 1 / h;\n            return {\n                texture,\n                fbo,\n                width: w,\n                height: h,\n                texelSizeX,\n                texelSizeY,\n                attach (id) {\n                    gl.activeTexture(gl.TEXTURE0 + id);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    return id;\n                }\n            };\n        }\n        function createDoubleFBO(w, h, internalFormat, format, type, param) {\n            const fbo1 = createFBO(w, h, internalFormat, format, type, param);\n            const fbo2 = createFBO(w, h, internalFormat, format, type, param);\n            return {\n                width: w,\n                height: h,\n                texelSizeX: fbo1.texelSizeX,\n                texelSizeY: fbo1.texelSizeY,\n                read: fbo1,\n                write: fbo2,\n                swap () {\n                    const tmp = this.read;\n                    this.read = this.write;\n                    this.write = tmp;\n                }\n            };\n        }\n        function resizeFBO(target, w, h, internalFormat, format, type, param) {\n            const newFBO = createFBO(w, h, internalFormat, format, type, param);\n            copyProgram.bind();\n            if (copyProgram.uniforms.uTexture) gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n            blit(newFBO, false);\n            return newFBO;\n        }\n        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n            if (target.width === w && target.height === h) return target;\n            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n            target.write = createFBO(w, h, internalFormat, format, type, param);\n            target.width = w;\n            target.height = h;\n            target.texelSizeX = 1 / w;\n            target.texelSizeY = 1 / h;\n            return target;\n        }\n        function initFramebuffers() {\n            const simRes = getResolution(config.SIM_RESOLUTION);\n            const dyeRes = getResolution(config.DYE_RESOLUTION);\n            const texType = ext.halfFloatTexType;\n            const rgba = ext.formatRGBA;\n            const rg = ext.formatRG;\n            const r = ext.formatR;\n            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n            gl.disable(gl.BLEND);\n            if (!dye) {\n                dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            } else {\n                dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            }\n            if (!velocity) {\n                velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            } else {\n                velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            }\n            divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n        }\n        function updateKeywords() {\n            const displayKeywords = [];\n            if (config.SHADING) displayKeywords.push(\"SHADING\");\n            displayMaterial.setKeywords(displayKeywords);\n        }\n        function getResolution(resolution) {\n            const w = gl.drawingBufferWidth;\n            const h = gl.drawingBufferHeight;\n            const aspectRatio = w / h;\n            let aspect = aspectRatio < 1 ? 1 / aspectRatio : aspectRatio;\n            const min = Math.round(resolution);\n            const max = Math.round(resolution * aspect);\n            if (w > h) {\n                return {\n                    width: max,\n                    height: min\n                };\n            }\n            return {\n                width: min,\n                height: max\n            };\n        }\n        function scaleByPixelRatio(input) {\n            const pixelRatio = window.devicePixelRatio || 1;\n            return Math.floor(input * pixelRatio);\n        }\n        updateKeywords();\n        initFramebuffers();\n        let lastUpdateTime = Date.now();\n        let colorUpdateTimer = 0.0;\n        function updateFrame() {\n            const dt = calcDeltaTime();\n            if (resizeCanvas()) initFramebuffers();\n            updateColors(dt);\n            applyInputs();\n            step(dt);\n            render(null);\n            requestAnimationFrame(updateFrame);\n        }\n        function calcDeltaTime() {\n            const now = Date.now();\n            let dt = (now - lastUpdateTime) / 1000;\n            dt = Math.min(dt, 0.016666);\n            lastUpdateTime = now;\n            return dt;\n        }\n        function resizeCanvas() {\n            const width = scaleByPixelRatio(canvas.clientWidth);\n            const height = scaleByPixelRatio(canvas.clientHeight);\n            if (canvas.width !== width || canvas.height !== height) {\n                canvas.width = width;\n                canvas.height = height;\n                return true;\n            }\n            return false;\n        }\n        function updateColors(dt) {\n            colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n            if (colorUpdateTimer >= 1) {\n                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n                pointers.forEach((p)=>{\n                    p.color = generateColor();\n                });\n            }\n        }\n        function applyInputs() {\n            for (const p of pointers){\n                if (p.moved) {\n                    p.moved = false;\n                    splatPointer(p);\n                }\n            }\n        }\n        function step(dt) {\n            gl.disable(gl.BLEND);\n            curlProgram.bind();\n            if (curlProgram.uniforms.texelSize) {\n                gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (curlProgram.uniforms.uVelocity) {\n                gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            blit(curl);\n            vorticityProgram.bind();\n            if (vorticityProgram.uniforms.texelSize) {\n                gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (vorticityProgram.uniforms.uVelocity) {\n                gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            if (vorticityProgram.uniforms.uCurl) {\n                gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n            }\n            if (vorticityProgram.uniforms.curl) {\n                gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n            }\n            if (vorticityProgram.uniforms.dt) {\n                gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n            }\n            blit(velocity.write);\n            velocity.swap();\n            divergenceProgram.bind();\n            if (divergenceProgram.uniforms.texelSize) {\n                gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (divergenceProgram.uniforms.uVelocity) {\n                gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            blit(divergence);\n            clearProgram.bind();\n            if (clearProgram.uniforms.uTexture) {\n                gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n            }\n            if (clearProgram.uniforms.value) {\n                gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n            }\n            blit(pressure.write);\n            pressure.swap();\n            pressureProgram.bind();\n            if (pressureProgram.uniforms.texelSize) {\n                gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (pressureProgram.uniforms.uDivergence) {\n                gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n            }\n            for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n                if (pressureProgram.uniforms.uPressure) {\n                    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n                }\n                blit(pressure.write);\n                pressure.swap();\n            }\n            gradienSubtractProgram.bind();\n            if (gradienSubtractProgram.uniforms.texelSize) {\n                gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (gradienSubtractProgram.uniforms.uPressure) {\n                gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n            }\n            if (gradienSubtractProgram.uniforms.uVelocity) {\n                gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n            }\n            blit(velocity.write);\n            velocity.swap();\n            advectionProgram.bind();\n            if (advectionProgram.uniforms.texelSize) {\n                gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (!ext.supportLinearFiltering && advectionProgram.uniforms.dyeTexelSize) {\n                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            const velocityId = velocity.read.attach(0);\n            if (advectionProgram.uniforms.uVelocity) {\n                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n            }\n            if (advectionProgram.uniforms.uSource) {\n                gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n            }\n            if (advectionProgram.uniforms.dt) {\n                gl.uniform1f(advectionProgram.uniforms.dt, dt);\n            }\n            if (advectionProgram.uniforms.dissipation) {\n                gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n            }\n            blit(velocity.write);\n            velocity.swap();\n            if (!ext.supportLinearFiltering && advectionProgram.uniforms.dyeTexelSize) {\n                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n            }\n            if (advectionProgram.uniforms.uVelocity) {\n                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            if (advectionProgram.uniforms.uSource) {\n                gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n            }\n            if (advectionProgram.uniforms.dissipation) {\n                gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n            }\n            blit(dye.write);\n            dye.swap();\n        }\n        function render(target) {\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n            drawDisplay(target);\n        }\n        function drawDisplay(target) {\n            const width = target ? target.width : gl.drawingBufferWidth;\n            const height = target ? target.height : gl.drawingBufferHeight;\n            displayMaterial.bind();\n            if (config.SHADING && displayMaterial.uniforms.texelSize) {\n                gl.uniform2f(displayMaterial.uniforms.texelSize, 1 / width, 1 / height);\n            }\n            if (displayMaterial.uniforms.uTexture) {\n                gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n            }\n            blit(target, false);\n        }\n        function splatPointer(pointer) {\n            const dx = pointer.deltaX * config.SPLAT_FORCE;\n            const dy = pointer.deltaY * config.SPLAT_FORCE;\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n        }\n        function clickSplat(pointer) {\n            const color = generateColor();\n            color.r *= 10;\n            color.g *= 10;\n            color.b *= 10;\n            const dx = 10 * (Math.random() - 0.5);\n            const dy = 30 * (Math.random() - 0.5);\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n        }\n        function splat(x, y, dx, dy, color) {\n            splatProgram.bind();\n            if (splatProgram.uniforms.uTarget) {\n                gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n            }\n            if (splatProgram.uniforms.aspectRatio) {\n                gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n            }\n            if (splatProgram.uniforms.point) {\n                gl.uniform2f(splatProgram.uniforms.point, x, y);\n            }\n            if (splatProgram.uniforms.color) {\n                gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0);\n            }\n            if (splatProgram.uniforms.radius) {\n                gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100));\n            }\n            blit(velocity.write);\n            velocity.swap();\n            if (splatProgram.uniforms.uTarget) {\n                gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n            }\n            if (splatProgram.uniforms.color) {\n                gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n            }\n            blit(dye.write);\n            dye.swap();\n        }\n        function correctRadius(radius) {\n            const aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) radius *= aspectRatio;\n            return radius;\n        }\n        function updatePointerDownData(pointer, id, posX, posY) {\n            pointer.id = id;\n            pointer.down = true;\n            pointer.moved = false;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1 - posY / canvas.height;\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.deltaX = 0;\n            pointer.deltaY = 0;\n            pointer.color = generateColor();\n        }\n        function updatePointerMoveData(pointer, posX, posY, color) {\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1 - posY / canvas.height;\n            pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n            pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n            pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n            pointer.color = color;\n        }\n        function updatePointerUpData(pointer) {\n            pointer.down = false;\n        }\n        function correctDeltaX(delta) {\n            const aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio < 1) delta *= aspectRatio;\n            return delta;\n        }\n        function correctDeltaY(delta) {\n            const aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) delta /= aspectRatio;\n            return delta;\n        }\n        function generateColor() {\n            const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n            c.r *= 0.15;\n            c.g *= 0.15;\n            c.b *= 0.15;\n            return c;\n        }\n        function HSVtoRGB(h, s, v) {\n            let r = 0, g = 0, b = 0;\n            const i = Math.floor(h * 6);\n            const f = h * 6 - i;\n            const p = v * (1 - s);\n            const q = v * (1 - f * s);\n            const t = v * (1 - (1 - f) * s);\n            switch(i % 6){\n                case 0:\n                    r = v;\n                    g = t;\n                    b = p;\n                    break;\n                case 1:\n                    r = q;\n                    g = v;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = v;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = v;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = v;\n                    break;\n                case 5:\n                    r = v;\n                    g = p;\n                    b = q;\n                    break;\n            }\n            return {\n                r,\n                g,\n                b\n            };\n        }\n        function wrap(value, min, max) {\n            const range = max - min;\n            if (range === 0) return min;\n            return (value - min) % range + min;\n        }\n        window.addEventListener(\"mousedown\", (e)=>{\n            const pointer = pointers[0];\n            const posX = scaleByPixelRatio(e.clientX);\n            const posY = scaleByPixelRatio(e.clientY);\n            updatePointerDownData(pointer, -1, posX, posY);\n            clickSplat(pointer);\n        });\n        function handleFirstMouseMove(e) {\n            const pointer = pointers[0];\n            const posX = scaleByPixelRatio(e.clientX);\n            const posY = scaleByPixelRatio(e.clientY);\n            const color = generateColor();\n            updateFrame();\n            updatePointerMoveData(pointer, posX, posY, color);\n            document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n        }\n        document.body.addEventListener(\"mousemove\", handleFirstMouseMove);\n        window.addEventListener(\"mousemove\", (e)=>{\n            const pointer = pointers[0];\n            const posX = scaleByPixelRatio(e.clientX);\n            const posY = scaleByPixelRatio(e.clientY);\n            const color = pointer.color;\n            updatePointerMoveData(pointer, posX, posY, color);\n        });\n        function handleFirstTouchStart(e) {\n            const touches = e.targetTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                const posX = scaleByPixelRatio(touches[i].clientX);\n                const posY = scaleByPixelRatio(touches[i].clientY);\n                updateFrame();\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n            document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n        }\n        document.body.addEventListener(\"touchstart\", handleFirstTouchStart);\n        window.addEventListener(\"touchstart\", (e)=>{\n            const touches = e.targetTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                const posX = scaleByPixelRatio(touches[i].clientX);\n                const posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n        }, false);\n        window.addEventListener(\"touchmove\", (e)=>{\n            const touches = e.targetTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                const posX = scaleByPixelRatio(touches[i].clientX);\n                const posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerMoveData(pointer, posX, posY, pointer.color);\n            }\n        }, false);\n        window.addEventListener(\"touchend\", (e)=>{\n            const touches = e.changedTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                updatePointerUpData(pointer);\n            }\n        });\n    }, [\n        SIM_RESOLUTION,\n        DYE_RESOLUTION,\n        CAPTURE_RESOLUTION,\n        DENSITY_DISSIPATION,\n        VELOCITY_DISSIPATION,\n        PRESSURE,\n        PRESSURE_ITERATIONS,\n        CURL,\n        SPLAT_RADIUS,\n        SPLAT_FORCE,\n        SHADING,\n        COLOR_UPDATE_SPEED,\n        BACK_COLOR,\n        TRANSPARENT\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed top-0 left-0 z-50 pointer-events-none w-full h-full\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            id: \"fluid\",\n            className: \"w-screen h-screen block\"\n        }, void 0, false, {\n            fileName: \"D:\\\\workspace\\\\Project\\\\Portfolio\\\\components\\\\SplashCursor.tsx\",\n            lineNumber: 1514,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\workspace\\\\Project\\\\Portfolio\\\\components\\\\SplashCursor.tsx\",\n        lineNumber: 1513,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU3BsYXNoQ3Vyc29yLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDaUQ7QUFzQ2pELFNBQVNHO0lBQ1AsT0FBTztRQUNMQyxJQUFJLENBQUM7UUFDTEMsV0FBVztRQUNYQyxXQUFXO1FBQ1hDLGVBQWU7UUFDZkMsZUFBZTtRQUNmQyxRQUFRO1FBQ1JDLFFBQVE7UUFDUkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE9BQU87WUFBRUMsR0FBRztZQUFHQyxHQUFHO1lBQUdDLEdBQUc7UUFBRTtJQUM1QjtBQUNGO0FBRWUsU0FBU0MsYUFBYSxLQWVqQjtRQWZpQixFQUNuQ0MsaUJBQWlCLEdBQUcsRUFDcEJDLGlCQUFpQixJQUFJLEVBQ3JCQyxxQkFBcUIsR0FBRyxFQUN4QkMsc0JBQXNCLEdBQUcsRUFDekJDLHVCQUF1QixDQUFDLEVBQ3hCQyxXQUFXLEdBQUcsRUFDZEMsc0JBQXNCLEVBQUUsRUFDeEJDLE9BQU8sQ0FBQyxFQUNSQyxlQUFlLEdBQUcsRUFDbEJDLGNBQWMsSUFBSSxFQUNsQkMsVUFBVSxJQUFJLEVBQ2RDLHFCQUFxQixFQUFFLEVBQ3ZCQyxhQUFhO1FBQUVoQixHQUFHO1FBQUtDLEdBQUc7UUFBR0MsR0FBRztJQUFFLENBQUMsRUFDbkNlLGNBQWMsSUFBSSxFQUNBLEdBZmlCOztJQWdCbkMsTUFBTUMsWUFBWTlCLDZDQUFNQSxDQUFvQjtJQUU1Q0QsZ0RBQVNBLENBQUM7UUFDUixNQUFNZ0MsU0FBU0QsVUFBVUUsT0FBTztRQUNoQyxJQUFJLENBQUNELFFBQVE7UUFFYixJQUFJRSxXQUFzQjtZQUFDaEM7U0FBbUI7UUFFOUMsSUFBSWlDLFNBQVM7WUFDWGxCLGdCQUFnQkE7WUFDaEJDLGdCQUFnQkE7WUFDaEJDLG9CQUFvQkE7WUFDcEJDLHFCQUFxQkE7WUFDckJDLHNCQUFzQkE7WUFDdEJDLFVBQVVBO1lBQ1ZDLHFCQUFxQkE7WUFDckJDLE1BQU1BO1lBQ05DLGNBQWNBO1lBQ2RDLGFB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QUU7WUFDM0IsSUFBSyxJQUFJOEQsSUFBSSxHQUFHQSxJQUFJNE4sUUFBUTlOLE1BQU0sRUFBRUUsSUFBSztnQkFDdkMsTUFBTW9NLE9BQU96RCxrQkFBa0JpRixPQUFPLENBQUM1TixFQUFFLENBQUNxTixPQUFPO2dCQUNqRCxNQUFNaEIsT0FBTzFELGtCQUFrQmlGLE9BQU8sQ0FBQzVOLEVBQUUsQ0FBQ3NOLE9BQU87Z0JBQ2pEaEIsc0JBQXNCaEIsU0FBU2MsTUFBTUMsTUFBTWYsUUFBUTFRLEtBQUs7WUFDMUQ7UUFDRixHQUNBO1FBR0ZrTyxPQUFPcUUsZ0JBQWdCLENBQUMsWUFBWSxDQUFDQztZQUNuQyxNQUFNUSxVQUFVUixFQUFFVyxjQUFjO1lBQ2hDLE1BQU16QyxVQUFVcFAsUUFBUSxDQUFDLEVBQUU7WUFDM0IsSUFBSyxJQUFJOEQsSUFBSSxHQUFHQSxJQUFJNE4sUUFBUTlOLE1BQU0sRUFBRUUsSUFBSztnQkFDdkMwTSxvQkFBb0JwQjtZQUN0QjtRQUNGO0lBQ0YsR0FBRztRQUNEclE7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7S0FDRDtJQUVELHFCQUNFLDhEQUFDa1M7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ2pTO1lBQ0NrUyxLQUFLblM7WUFDTDVCLElBQUc7WUFDSDhULFdBQVU7Ozs7Ozs7Ozs7O0FBSWxCO0dBMTdDd0JqVDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NwbGFzaEN1cnNvci50c3g/YWJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgQ29sb3JSR0Ige1xuICByOiBudW1iZXI7XG4gIGc6IG51bWJlcjtcbiAgYjogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU3BsYXNoQ3Vyc29yUHJvcHMge1xuICBTSU1fUkVTT0xVVElPTj86IG51bWJlcjtcbiAgRFlFX1JFU09MVVRJT04/OiBudW1iZXI7XG4gIENBUFRVUkVfUkVTT0xVVElPTj86IG51bWJlcjtcbiAgREVOU0lUWV9ESVNTSVBBVElPTj86IG51bWJlcjtcbiAgVkVMT0NJVFlfRElTU0lQQVRJT04/OiBudW1iZXI7XG4gIFBSRVNTVVJFPzogbnVtYmVyO1xuICBQUkVTU1VSRV9JVEVSQVRJT05TPzogbnVtYmVyO1xuICBDVVJMPzogbnVtYmVyO1xuICBTUExBVF9SQURJVVM/OiBudW1iZXI7XG4gIFNQTEFUX0ZPUkNFPzogbnVtYmVyO1xuICBTSEFESU5HPzogYm9vbGVhbjtcbiAgQ09MT1JfVVBEQVRFX1NQRUVEPzogbnVtYmVyO1xuICBCQUNLX0NPTE9SPzogQ29sb3JSR0I7XG4gIFRSQU5TUEFSRU5UPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIFBvaW50ZXIge1xuICBpZDogbnVtYmVyO1xuICB0ZXhjb29yZFg6IG51bWJlcjtcbiAgdGV4Y29vcmRZOiBudW1iZXI7XG4gIHByZXZUZXhjb29yZFg6IG51bWJlcjtcbiAgcHJldlRleGNvb3JkWTogbnVtYmVyO1xuICBkZWx0YVg6IG51bWJlcjtcbiAgZGVsdGFZOiBudW1iZXI7XG4gIGRvd246IGJvb2xlYW47XG4gIG1vdmVkOiBib29sZWFuO1xuICBjb2xvcjogQ29sb3JSR0I7XG59XG5cbmZ1bmN0aW9uIHBvaW50ZXJQcm90b3R5cGUoKTogUG9pbnRlciB7XG4gIHJldHVybiB7XG4gICAgaWQ6IC0xLFxuICAgIHRleGNvb3JkWDogMCxcbiAgICB0ZXhjb29yZFk6IDAsXG4gICAgcHJldlRleGNvb3JkWDogMCxcbiAgICBwcmV2VGV4Y29vcmRZOiAwLFxuICAgIGRlbHRhWDogMCxcbiAgICBkZWx0YVk6IDAsXG4gICAgZG93bjogZmFsc2UsXG4gICAgbW92ZWQ6IGZhbHNlLFxuICAgIGNvbG9yOiB7IHI6IDAsIGc6IDAsIGI6IDAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3BsYXNoQ3Vyc29yKHtcbiAgU0lNX1JFU09MVVRJT04gPSAxMjgsXG4gIERZRV9SRVNPTFVUSU9OID0gMTQ0MCxcbiAgQ0FQVFVSRV9SRVNPTFVUSU9OID0gNTEyLFxuICBERU5TSVRZX0RJU1NJUEFUSU9OID0gMy41LFxuICBWRUxPQ0lUWV9ESVNTSVBBVElPTiA9IDIsXG4gIFBSRVNTVVJFID0gMC4xLFxuICBQUkVTU1VSRV9JVEVSQVRJT05TID0gMjAsXG4gIENVUkwgPSAzLFxuICBTUExBVF9SQURJVVMgPSAwLjIsXG4gIFNQTEFUX0ZPUkNFID0gNjAwMCxcbiAgU0hBRElORyA9IHRydWUsXG4gIENPTE9SX1VQREFURV9TUEVFRCA9IDEwLFxuICBCQUNLX0NPTE9SID0geyByOiAwLjUsIGc6IDAsIGI6IDAgfSxcbiAgVFJBTlNQQVJFTlQgPSB0cnVlLFxufTogU3BsYXNoQ3Vyc29yUHJvcHMpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICBsZXQgcG9pbnRlcnM6IFBvaW50ZXJbXSA9IFtwb2ludGVyUHJvdG90eXBlKCldO1xuXG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIFNJTV9SRVNPTFVUSU9OOiBTSU1fUkVTT0xVVElPTiEsXG4gICAgICBEWUVfUkVTT0xVVElPTjogRFlFX1JFU09MVVRJT04hLFxuICAgICAgQ0FQVFVSRV9SRVNPTFVUSU9OOiBDQVBUVVJFX1JFU09MVVRJT04hLFxuICAgICAgREVOU0lUWV9ESVNTSVBBVElPTjogREVOU0lUWV9ESVNTSVBBVElPTiEsXG4gICAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTjogVkVMT0NJVFlfRElTU0lQQVRJT04hLFxuICAgICAgUFJFU1NVUkU6IFBSRVNTVVJFISxcbiAgICAgIFBSRVNTVVJFX0lURVJBVElPTlM6IFBSRVNTVVJFX0lURVJBVElPTlMhLFxuICAgICAgQ1VSTDogQ1VSTCEsXG4gICAgICBTUExBVF9SQURJVVM6IFNQTEFUX1JBRElVUyEsXG4gICAgICBTUExBVF9GT1JDRTogU1BMQVRfRk9SQ0UhLFxuICAgICAgU0hBRElORyxcbiAgICAgIENPTE9SX1VQREFURV9TUEVFRDogQ09MT1JfVVBEQVRFX1NQRUVEISxcbiAgICAgIFBBVVNFRDogZmFsc2UsXG4gICAgICBCQUNLX0NPTE9SLFxuICAgICAgVFJBTlNQQVJFTlQsXG4gICAgfTtcblxuICAgIGNvbnN0IHsgZ2wsIGV4dCB9ID0gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcyk7XG4gICAgaWYgKCFnbCB8fCAhZXh0KSByZXR1cm47XG5cbiAgICBpZiAoIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICBjb25maWcuRFlFX1JFU09MVVRJT04gPSAyNTY7XG4gICAgICBjb25maWcuU0hBRElORyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoXG4gICAgICAgIFwid2ViZ2wyXCIsXG4gICAgICAgIHBhcmFtc1xuICAgICAgKSBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHwgbnVsbDtcblxuICAgICAgaWYgKCFnbCkge1xuICAgICAgICBnbCA9IChjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHBhcmFtcykgfHxcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcbiAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICApKSBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBXZWJHTC5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzV2ViR0wyID0gXCJkcmF3QnVmZmVyc1wiIGluIGdsO1xuXG4gICAgICBsZXQgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IGZhbHNlO1xuICAgICAgbGV0IGhhbGZGbG9hdCA9IG51bGw7XG5cbiAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKTtcbiAgICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9ICEhKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLmdldEV4dGVuc2lvbihcbiAgICAgICAgICBcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYWxmRmxvYXQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO1xuICAgICAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gISFnbC5nZXRFeHRlbnNpb24oXG4gICAgICAgICAgXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhclwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSk7XG5cbiAgICAgIGNvbnN0IGhhbGZGbG9hdFRleFR5cGUgPSBpc1dlYkdMMlxuICAgICAgICA/IChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5IQUxGX0ZMT0FUXG4gICAgICAgIDogKGhhbGZGbG9hdCAmJiAoaGFsZkZsb2F0IGFzIGFueSkuSEFMRl9GTE9BVF9PRVMpIHx8IDA7XG5cbiAgICAgIGxldCBmb3JtYXRSR0JBOiBhbnk7XG4gICAgICBsZXQgZm9ybWF0Ukc6IGFueTtcbiAgICAgIGxldCBmb3JtYXRSOiBhbnk7XG5cbiAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICBmb3JtYXRSR0JBID0gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgICAgIGdsLFxuICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SR0JBMTZGLFxuICAgICAgICAgIGdsLlJHQkEsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICApO1xuICAgICAgICBmb3JtYXRSRyA9IGdldFN1cHBvcnRlZEZvcm1hdChcbiAgICAgICAgICBnbCxcbiAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkcxNkYsXG4gICAgICAgICAgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHLFxuICAgICAgICAgIGhhbGZGbG9hdFRleFR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgZm9ybWF0UiA9IGdldFN1cHBvcnRlZEZvcm1hdChcbiAgICAgICAgICBnbCxcbiAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUjE2RixcbiAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkVELFxuICAgICAgICAgIGhhbGZGbG9hdFRleFR5cGVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdFJHQkEgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgICAgICBmb3JtYXRSRyA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQSwgZ2wuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgICAgIGZvcm1hdFIgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnbCxcbiAgICAgICAgZXh0OiB7XG4gICAgICAgICAgZm9ybWF0UkdCQSxcbiAgICAgICAgICBmb3JtYXRSRyxcbiAgICAgICAgICBmb3JtYXRSLFxuICAgICAgICAgIGhhbGZGbG9hdFRleFR5cGUsXG4gICAgICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyLFxuICAgICAgZm9ybWF0OiBudW1iZXIsXG4gICAgICB0eXBlOiBudW1iZXJcbiAgICApOiB7IGludGVybmFsRm9ybWF0OiBudW1iZXI7IGZvcm1hdDogbnVtYmVyIH0gfCBudWxsIHtcbiAgICAgIGlmICghc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoZ2wsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUpKSB7XG4gICAgICAgIGlmIChcImRyYXdCdWZmZXJzXCIgaW4gZ2wpIHtcbiAgICAgICAgICBjb25zdCBnbDIgPSBnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgICAgIHN3aXRjaCAoaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgZ2wyLlIxNkY6XG4gICAgICAgICAgICAgIHJldHVybiBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wyLCBnbDIuUkcxNkYsIGdsMi5SRywgdHlwZSk7XG4gICAgICAgICAgICBjYXNlIGdsMi5SRzE2RjpcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbDIsIGdsMi5SR0JBMTZGLCBnbDIuUkdCQSwgdHlwZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoXG4gICAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiBudW1iZXIsXG4gICAgICBmb3JtYXQ6IG51bWJlcixcbiAgICAgIHR5cGU6IG51bWJlclxuICAgICkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGlmICghdGV4dHVyZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAwLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgNCxcbiAgICAgICAgNCxcbiAgICAgICAgMCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBudWxsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgaWYgKCFmYm8pIHJldHVybiBmYWxzZTtcblxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pO1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzaENvZGUoczogc3RyaW5nKSB7XG4gICAgICBpZiAoIXMubGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgIGxldCBoYXNoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoIHw9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRLZXl3b3Jkcyhzb3VyY2U6IHN0cmluZywga2V5d29yZHM6IHN0cmluZ1tdIHwgbnVsbCkge1xuICAgICAgaWYgKCFrZXl3b3JkcykgcmV0dXJuIHNvdXJjZTtcbiAgICAgIGxldCBrZXl3b3Jkc1N0cmluZyA9IFwiXCI7XG4gICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2Yga2V5d29yZHMpIHtcbiAgICAgICAga2V5d29yZHNTdHJpbmcgKz0gYCNkZWZpbmUgJHtrZXl3b3JkfVxcbmA7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5d29yZHNTdHJpbmcgKyBzb3VyY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGlsZVNoYWRlcihcbiAgICAgIHR5cGU6IG51bWJlcixcbiAgICAgIHNvdXJjZTogc3RyaW5nLFxuICAgICAga2V5d29yZHM6IHN0cmluZ1tdIHwgbnVsbCA9IG51bGxcbiAgICApOiBXZWJHTFNoYWRlciB8IG51bGwge1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYWRkS2V5d29yZHMoc291cmNlLCBrZXl3b3Jkcyk7XG4gICAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICBpZiAoIXNoYWRlcikgcmV0dXJuIG51bGw7XG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKFxuICAgICAgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlciB8IG51bGwsXG4gICAgICBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsXG4gICAgKTogV2ViR0xQcm9ncmFtIHwgbnVsbCB7XG4gICAgICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlmb3Jtcyhwcm9ncmFtOiBXZWJHTFByb2dyYW0pIHtcbiAgICAgIGxldCB1bmlmb3JtczogUmVjb3JkPHN0cmluZywgV2ViR0xVbmlmb3JtTG9jYXRpb24gfCBudWxsPiA9IHt9O1xuICAgICAgY29uc3QgdW5pZm9ybUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XG4gICAgICAgIGlmICh1bmlmb3JtSW5mbykge1xuICAgICAgICAgIHVuaWZvcm1zW3VuaWZvcm1JbmZvLm5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKFxuICAgICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICAgIHVuaWZvcm1JbmZvLm5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5pZm9ybXM7XG4gICAgfVxuXG4gICAgY2xhc3MgUHJvZ3JhbSB7XG4gICAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW0gfCBudWxsO1xuICAgICAgdW5pZm9ybXM6IFJlY29yZDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uIHwgbnVsbD47XG5cbiAgICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyIHwgbnVsbCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyIHwgbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnByb2dyYW0gPyBnZXRVbmlmb3Jtcyh0aGlzLnByb2dyYW0pIDoge307XG4gICAgICB9XG5cbiAgICAgIGJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0pIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBNYXRlcmlhbCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyIHwgbnVsbDtcbiAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmc7XG4gICAgICBwcm9ncmFtczogUmVjb3JkPG51bWJlciwgV2ViR0xQcm9ncmFtIHwgbnVsbD47XG4gICAgICBhY3RpdmVQcm9ncmFtOiBXZWJHTFByb2dyYW0gfCBudWxsO1xuICAgICAgdW5pZm9ybXM6IFJlY29yZDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uIHwgbnVsbD47XG5cbiAgICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyIHwgbnVsbCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHN0cmluZ1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBzZXRLZXl3b3JkcyhrZXl3b3Jkczogc3RyaW5nW10pIHtcbiAgICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGt3IG9mIGtleXdvcmRzKSB7XG4gICAgICAgICAgaGFzaCArPSBoYXNoQ29kZShrdyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb2dyYW0gPSB0aGlzLnByb2dyYW1zW2hhc2hdO1xuICAgICAgICBpZiAocHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSxcbiAgICAgICAgICAgIGtleXdvcmRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICAgIHRoaXMucHJvZ3JhbXNbaGFzaF0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLmFjdGl2ZVByb2dyYW0pIHJldHVybjtcbiAgICAgICAgaWYgKHByb2dyYW0pIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zID0gZ2V0VW5pZm9ybXMocHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgIH1cblxuICAgICAgYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUHJvZ3JhbSkge1xuICAgICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5hY3RpdmVQcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VWZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuVkVSVEVYX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2VXYgPSBhUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgICAgIHZMID0gdlV2IC0gdmVjMih0ZXhlbFNpemUueCwgMC4wKTtcbiAgICAgICAgdlIgPSB2VXYgKyB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICB2VCA9IHZVdiArIHZlYzIoMC4wLCB0ZXhlbFNpemUueSk7XG4gICAgICAgIHZCID0gdlV2IC0gdmVjMigwLjAsIHRleGVsU2l6ZS55KTtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgfVxuICAgIGBcbiAgICApO1xuXG4gICAgY29uc3QgY29weVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgICB9XG4gICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBjbGVhclNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdmFsdWU7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmFsdWUgKiB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgICB9XG4gICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBkaXNwbGF5U2hhZGVyU291cmNlID0gYFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVEaXRoZXJpbmc7XG4gICAgICB1bmlmb3JtIHZlYzIgZGl0aGVyU2NhbGU7XG4gICAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuXG4gICAgICB2ZWMzIGxpbmVhclRvR2FtbWEgKHZlYzMgY29sb3IpIHtcbiAgICAgICAgICBjb2xvciA9IG1heChjb2xvciwgdmVjMygwKSk7XG4gICAgICAgICAgcmV0dXJuIG1heCgxLjA1NSAqIHBvdyhjb2xvciwgdmVjMygwLjQxNjY2NjY2NykpIC0gMC4wNTUsIHZlYzMoMCkpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgIHZlYzMgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS5yZ2I7XG4gICAgICAgICAgI2lmZGVmIFNIQURJTkdcbiAgICAgICAgICAgICAgdmVjMyBsYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpLnJnYjtcbiAgICAgICAgICAgICAgdmVjMyByYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlIpLnJnYjtcbiAgICAgICAgICAgICAgdmVjMyB0YyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpLnJnYjtcbiAgICAgICAgICAgICAgdmVjMyBiYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpLnJnYjtcblxuICAgICAgICAgICAgICBmbG9hdCBkeCA9IGxlbmd0aChyYykgLSBsZW5ndGgobGMpO1xuICAgICAgICAgICAgICBmbG9hdCBkeSA9IGxlbmd0aCh0YykgLSBsZW5ndGgoYmMpO1xuXG4gICAgICAgICAgICAgIHZlYzMgbiA9IG5vcm1hbGl6ZSh2ZWMzKGR4LCBkeSwgbGVuZ3RoKHRleGVsU2l6ZSkpKTtcbiAgICAgICAgICAgICAgdmVjMyBsID0gdmVjMygwLjAsIDAuMCwgMS4wKTtcblxuICAgICAgICAgICAgICBmbG9hdCBkaWZmdXNlID0gY2xhbXAoZG90KG4sIGwpICsgMC43LCAwLjcsIDEuMCk7XG4gICAgICAgICAgICAgIGMgKj0gZGlmZnVzZTtcbiAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgIGZsb2F0IGEgPSBtYXgoYy5yLCBtYXgoYy5nLCBjLmIpKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMsIGEpO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBzcGxhdFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUYXJnZXQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IGFzcGVjdFJhdGlvO1xuICAgICAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICAgICAgdW5pZm9ybSB2ZWMyIHBvaW50O1xuICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgdmVjMiBwID0gdlV2IC0gcG9pbnQueHk7XG4gICAgICAgICAgcC54ICo9IGFzcGVjdFJhdGlvO1xuICAgICAgICAgIHZlYzMgc3BsYXQgPSBleHAoLWRvdChwLCBwKSAvIHJhZGl1cykgKiBjb2xvcjtcbiAgICAgICAgICB2ZWMzIGJhc2UgPSB0ZXh0dXJlMkQodVRhcmdldCwgdlV2KS54eXo7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChiYXNlICsgc3BsYXQsIDEuMCk7XG4gICAgICB9XG4gICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBhZHZlY3Rpb25TaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U291cmNlO1xuICAgICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICAgIHVuaWZvcm0gdmVjMiBkeWVUZXhlbFNpemU7XG4gICAgICB1bmlmb3JtIGZsb2F0IGR0O1xuICAgICAgdW5pZm9ybSBmbG9hdCBkaXNzaXBhdGlvbjtcblxuICAgICAgdmVjNCBiaWxlcnAgKHNhbXBsZXIyRCBzYW0sIHZlYzIgdXYsIHZlYzIgdHNpemUpIHtcbiAgICAgICAgICB2ZWMyIHN0ID0gdXYgLyB0c2l6ZSAtIDAuNTtcbiAgICAgICAgICB2ZWMyIGl1diA9IGZsb29yKHN0KTtcbiAgICAgICAgICB2ZWMyIGZ1diA9IGZyYWN0KHN0KTtcblxuICAgICAgICAgIHZlYzQgYSA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMC41KSkgKiB0c2l6ZSk7XG4gICAgICAgICAgdmVjNCBiID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMS41LCAwLjUpKSAqIHRzaXplKTtcbiAgICAgICAgICB2ZWM0IGMgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigwLjUsIDEuNSkpICogdHNpemUpO1xuICAgICAgICAgIHZlYzQgZCA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDEuNSwgMS41KSkgKiB0c2l6ZSk7XG5cbiAgICAgICAgICByZXR1cm4gbWl4KG1peChhLCBiLCBmdXYueCksIG1peChjLCBkLCBmdXYueCksIGZ1di55KTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAjaWZkZWYgTUFOVUFMX0ZJTFRFUklOR1xuICAgICAgICAgICAgICB2ZWMyIGNvb3JkID0gdlV2IC0gZHQgKiBiaWxlcnAodVZlbG9jaXR5LCB2VXYsIHRleGVsU2l6ZSkueHkgKiB0ZXhlbFNpemU7XG4gICAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gYmlsZXJwKHVTb3VyY2UsIGNvb3JkLCBkeWVUZXhlbFNpemUpO1xuICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHkgKiB0ZXhlbFNpemU7XG4gICAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdGV4dHVyZTJEKHVTb3VyY2UsIGNvb3JkKTtcbiAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICBmbG9hdCBkZWNheSA9IDEuMCArIGRpc3NpcGF0aW9uICogZHQ7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gcmVzdWx0IC8gZGVjYXk7XG4gICAgICB9XG4gICAgYCxcbiAgICAgIGV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gbnVsbCA6IFtcIk1BTlVBTF9GSUxURVJJTkdcIl1cbiAgICApO1xuXG4gICAgY29uc3QgZGl2ZXJnZW5jZVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS54O1xuICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueDtcbiAgICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlQpLnk7XG4gICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS55O1xuXG4gICAgICAgICAgdmVjMiBDID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICBpZiAodkwueCA8IDAuMCkgeyBMID0gLUMueDsgfVxuICAgICAgICAgIGlmICh2Ui54ID4gMS4wKSB7IFIgPSAtQy54OyB9XG4gICAgICAgICAgaWYgKHZULnkgPiAxLjApIHsgVCA9IC1DLnk7IH1cbiAgICAgICAgICBpZiAodkIueSA8IDAuMCkgeyBCID0gLUMueTsgfVxuXG4gICAgICAgICAgZmxvYXQgZGl2ID0gMC41ICogKFIgLSBMICsgVCAtIEIpO1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGl2LCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGN1cmxTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueTtcbiAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlIpLnk7XG4gICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZUKS54O1xuICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueDtcbiAgICAgICAgICBmbG9hdCB2b3J0aWNpdHkgPSBSIC0gTCAtIFQgKyBCO1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC41ICogdm9ydGljaXR5LCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IHZvcnRpY2l0eVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVDdXJsO1xuICAgICAgdW5pZm9ybSBmbG9hdCBjdXJsO1xuICAgICAgdW5pZm9ybSBmbG9hdCBkdDtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVDdXJsLCB2TCkueDtcbiAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVDdXJsLCB2UikueDtcbiAgICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVDdXJsLCB2VCkueDtcbiAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVDdXJsLCB2QikueDtcbiAgICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVDdXJsLCB2VXYpLng7XG5cbiAgICAgICAgICB2ZWMyIGZvcmNlID0gMC41ICogdmVjMihhYnMoVCkgLSBhYnMoQiksIGFicyhSKSAtIGFicyhMKSk7XG4gICAgICAgICAgZm9yY2UgLz0gbGVuZ3RoKGZvcmNlKSArIDAuMDAwMTtcbiAgICAgICAgICBmb3JjZSAqPSBjdXJsICogQztcbiAgICAgICAgICBmb3JjZS55ICo9IC0xLjA7XG5cbiAgICAgICAgICB2ZWMyIHZlbG9jaXR5ID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICB2ZWxvY2l0eSArPSBmb3JjZSAqIGR0O1xuICAgICAgICAgIHZlbG9jaXR5ID0gbWluKG1heCh2ZWxvY2l0eSwgLTEwMDAuMCksIDEwMDAuMCk7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWxvY2l0eSwgMC4wLCAxLjApO1xuICAgICAgfVxuICAgIGBcbiAgICApO1xuXG4gICAgY29uc3QgcHJlc3N1cmVTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdURpdmVyZ2VuY2U7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2UikueDtcbiAgICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlQpLng7XG4gICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICAgIGZsb2F0IEMgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2VXYpLng7XG4gICAgICAgICAgZmxvYXQgZGl2ZXJnZW5jZSA9IHRleHR1cmUyRCh1RGl2ZXJnZW5jZSwgdlV2KS54O1xuICAgICAgICAgIGZsb2F0IHByZXNzdXJlID0gKEwgKyBSICsgQiArIFQgLSBkaXZlcmdlbmNlKSAqIDAuMjU7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChwcmVzc3VyZSwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICB9XG4gICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBncmFkaWVudFN1YnRyYWN0U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVQcmVzc3VyZTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2VCkueDtcbiAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgICAgdmVsb2NpdHkueHkgLT0gdmVjMihSIC0gTCwgVCAtIEIpO1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGJsaXQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCkhO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xXSksXG4gICAgICAgIGdsLlNUQVRJQ19EUkFXXG4gICAgICApO1xuICAgICAgY29uc3QgZWxlbUJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpITtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1CdWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgICAgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBV1xuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoMCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDApO1xuXG4gICAgICByZXR1cm4gKHRhcmdldDogRkJPIHwgbnVsbCwgZG9DbGVhciA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGlmICghZ2wpIHJldHVybjtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRhcmdldC5mYm8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb0NsZWFyKSB7XG4gICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcbiAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBpbnRlcmZhY2UgRkJPIHtcbiAgICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZTtcbiAgICAgIGZibzogV2ViR0xGcmFtZWJ1ZmZlcjtcbiAgICAgIHdpZHRoOiBudW1iZXI7XG4gICAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICAgIHRleGVsU2l6ZVg6IG51bWJlcjtcbiAgICAgIHRleGVsU2l6ZVk6IG51bWJlcjtcbiAgICAgIGF0dGFjaDogKGlkOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICB9XG5cbiAgICBpbnRlcmZhY2UgRG91YmxlRkJPIHtcbiAgICAgIHdpZHRoOiBudW1iZXI7XG4gICAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICAgIHRleGVsU2l6ZVg6IG51bWJlcjtcbiAgICAgIHRleGVsU2l6ZVk6IG51bWJlcjtcbiAgICAgIHJlYWQ6IEZCTztcbiAgICAgIHdyaXRlOiBGQk87XG4gICAgICBzd2FwOiAoKSA9PiB2b2lkO1xuICAgIH1cblxuICAgIGxldCBkeWU6IERvdWJsZUZCTztcbiAgICBsZXQgdmVsb2NpdHk6IERvdWJsZUZCTztcbiAgICBsZXQgZGl2ZXJnZW5jZTogRkJPO1xuICAgIGxldCBjdXJsOiBGQk87XG4gICAgbGV0IHByZXNzdXJlOiBEb3VibGVGQk87XG5cbiAgICBjb25zdCBjb3B5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNvcHlTaGFkZXIpO1xuICAgIGNvbnN0IGNsZWFyUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNsZWFyU2hhZGVyKTtcbiAgICBjb25zdCBzcGxhdFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBzcGxhdFNoYWRlcik7XG4gICAgY29uc3QgYWR2ZWN0aW9uUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGFkdmVjdGlvblNoYWRlcik7XG4gICAgY29uc3QgZGl2ZXJnZW5jZVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBkaXZlcmdlbmNlU2hhZGVyKTtcbiAgICBjb25zdCBjdXJsUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGN1cmxTaGFkZXIpO1xuICAgIGNvbnN0IHZvcnRpY2l0eVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCB2b3J0aWNpdHlTaGFkZXIpO1xuICAgIGNvbnN0IHByZXNzdXJlUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHByZXNzdXJlU2hhZGVyKTtcbiAgICBjb25zdCBncmFkaWVuU3VidHJhY3RQcm9ncmFtID0gbmV3IFByb2dyYW0oXG4gICAgICBiYXNlVmVydGV4U2hhZGVyLFxuICAgICAgZ3JhZGllbnRTdWJ0cmFjdFNoYWRlclxuICAgICk7XG4gICAgY29uc3QgZGlzcGxheU1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKGJhc2VWZXJ0ZXhTaGFkZXIsIGRpc3BsYXlTaGFkZXJTb3VyY2UpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRkJPKFxuICAgICAgdzogbnVtYmVyLFxuICAgICAgaDogbnVtYmVyLFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgICAgIGZvcm1hdDogbnVtYmVyLFxuICAgICAgdHlwZTogbnVtYmVyLFxuICAgICAgcGFyYW06IG51bWJlclxuICAgICk6IEZCTyB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCkhO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW0pO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAwLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgMCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgY29uc3QgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSE7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdywgaCk7XG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgY29uc3QgdGV4ZWxTaXplWCA9IDEgLyB3O1xuICAgICAgY29uc3QgdGV4ZWxTaXplWSA9IDEgLyBoO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICBmYm8sXG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIHRleGVsU2l6ZVgsXG4gICAgICAgIHRleGVsU2l6ZVksXG4gICAgICAgIGF0dGFjaChpZDogbnVtYmVyKSB7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKTtcbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURvdWJsZUZCTyhcbiAgICAgIHc6IG51bWJlcixcbiAgICAgIGg6IG51bWJlcixcbiAgICAgIGludGVybmFsRm9ybWF0OiBudW1iZXIsXG4gICAgICBmb3JtYXQ6IG51bWJlcixcbiAgICAgIHR5cGU6IG51bWJlcixcbiAgICAgIHBhcmFtOiBudW1iZXJcbiAgICApOiBEb3VibGVGQk8ge1xuICAgICAgY29uc3QgZmJvMSA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICBjb25zdCBmYm8yID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIHRleGVsU2l6ZVg6IGZibzEudGV4ZWxTaXplWCxcbiAgICAgICAgdGV4ZWxTaXplWTogZmJvMS50ZXhlbFNpemVZLFxuICAgICAgICByZWFkOiBmYm8xLFxuICAgICAgICB3cml0ZTogZmJvMixcbiAgICAgICAgc3dhcCgpIHtcbiAgICAgICAgICBjb25zdCB0bXAgPSB0aGlzLnJlYWQ7XG4gICAgICAgICAgdGhpcy5yZWFkID0gdGhpcy53cml0ZTtcbiAgICAgICAgICB0aGlzLndyaXRlID0gdG1wO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVGQk8oXG4gICAgICB0YXJnZXQ6IEZCTyxcbiAgICAgIHc6IG51bWJlcixcbiAgICAgIGg6IG51bWJlcixcbiAgICAgIGludGVybmFsRm9ybWF0OiBudW1iZXIsXG4gICAgICBmb3JtYXQ6IG51bWJlcixcbiAgICAgIHR5cGU6IG51bWJlcixcbiAgICAgIHBhcmFtOiBudW1iZXJcbiAgICApIHtcbiAgICAgIGNvbnN0IG5ld0ZCTyA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICBjb3B5UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAoY29weVByb2dyYW0udW5pZm9ybXMudVRleHR1cmUpXG4gICAgICAgIGdsLnVuaWZvcm0xaShjb3B5UHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgdGFyZ2V0LmF0dGFjaCgwKSk7XG4gICAgICBibGl0KG5ld0ZCTywgZmFsc2UpO1xuICAgICAgcmV0dXJuIG5ld0ZCTztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVEb3VibGVGQk8oXG4gICAgICB0YXJnZXQ6IERvdWJsZUZCTyxcbiAgICAgIHc6IG51bWJlcixcbiAgICAgIGg6IG51bWJlcixcbiAgICAgIGludGVybmFsRm9ybWF0OiBudW1iZXIsXG4gICAgICBmb3JtYXQ6IG51bWJlcixcbiAgICAgIHR5cGU6IG51bWJlcixcbiAgICAgIHBhcmFtOiBudW1iZXJcbiAgICApIHtcbiAgICAgIGlmICh0YXJnZXQud2lkdGggPT09IHcgJiYgdGFyZ2V0LmhlaWdodCA9PT0gaCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldC5yZWFkID0gcmVzaXplRkJPKFxuICAgICAgICB0YXJnZXQucmVhZCxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGFyYW1cbiAgICAgICk7XG4gICAgICB0YXJnZXQud3JpdGUgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICAgICAgdGFyZ2V0LndpZHRoID0gdztcbiAgICAgIHRhcmdldC5oZWlnaHQgPSBoO1xuICAgICAgdGFyZ2V0LnRleGVsU2l6ZVggPSAxIC8gdztcbiAgICAgIHRhcmdldC50ZXhlbFNpemVZID0gMSAvIGg7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRGcmFtZWJ1ZmZlcnMoKSB7XG4gICAgICBjb25zdCBzaW1SZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5TSU1fUkVTT0xVVElPTiEpO1xuICAgICAgY29uc3QgZHllUmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuRFlFX1JFU09MVVRJT04hKTtcblxuICAgICAgY29uc3QgdGV4VHlwZSA9IGV4dC5oYWxmRmxvYXRUZXhUeXBlO1xuICAgICAgY29uc3QgcmdiYSA9IGV4dC5mb3JtYXRSR0JBO1xuICAgICAgY29uc3QgcmcgPSBleHQuZm9ybWF0Ukc7XG4gICAgICBjb25zdCByID0gZXh0LmZvcm1hdFI7XG4gICAgICBjb25zdCBmaWx0ZXJpbmcgPSBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgaWYgKCFkeWUpIHtcbiAgICAgICAgZHllID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICAgIGR5ZVJlcy53aWR0aCxcbiAgICAgICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmdiYS5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR5ZSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgICAgICBkeWUsXG4gICAgICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgICAgIGR5ZVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZ2JhLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZlbG9jaXR5KSB7XG4gICAgICAgIHZlbG9jaXR5ID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICAgIHJnLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHJnLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVsb2NpdHkgPSByZXNpemVEb3VibGVGQk8oXG4gICAgICAgICAgdmVsb2NpdHksXG4gICAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmcuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmcuZm9ybWF0LFxuICAgICAgICAgIHRleFR5cGUsXG4gICAgICAgICAgZmlsdGVyaW5nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGRpdmVyZ2VuY2UgPSBjcmVhdGVGQk8oXG4gICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgci5mb3JtYXQsXG4gICAgICAgIHRleFR5cGUsXG4gICAgICAgIGdsLk5FQVJFU1RcbiAgICAgICk7XG4gICAgICBjdXJsID0gY3JlYXRlRkJPKFxuICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHIuZm9ybWF0LFxuICAgICAgICB0ZXhUeXBlLFxuICAgICAgICBnbC5ORUFSRVNUXG4gICAgICApO1xuICAgICAgcHJlc3N1cmUgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgci5mb3JtYXQsXG4gICAgICAgIHRleFR5cGUsXG4gICAgICAgIGdsLk5FQVJFU1RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlS2V5d29yZHMoKSB7XG4gICAgICBjb25zdCBkaXNwbGF5S2V5d29yZHM6IHN0cmluZ1tdID0gW107XG4gICAgICBpZiAoY29uZmlnLlNIQURJTkcpIGRpc3BsYXlLZXl3b3Jkcy5wdXNoKFwiU0hBRElOR1wiKTtcbiAgICAgIGRpc3BsYXlNYXRlcmlhbC5zZXRLZXl3b3JkcyhkaXNwbGF5S2V5d29yZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlc29sdXRpb24ocmVzb2x1dGlvbjogbnVtYmVyKSB7XG4gICAgICBjb25zdCB3ID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICAgICAgY29uc3QgaCA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHcgLyBoO1xuICAgICAgbGV0IGFzcGVjdCA9IGFzcGVjdFJhdGlvIDwgMSA/IDEgLyBhc3BlY3RSYXRpbyA6IGFzcGVjdFJhdGlvO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5yb3VuZChyZXNvbHV0aW9uKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgucm91bmQocmVzb2x1dGlvbiAqIGFzcGVjdCk7XG4gICAgICBpZiAodyA+IGgpIHtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IG1heCwgaGVpZ2h0OiBtaW4gfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiBtaW4sIGhlaWdodDogbWF4IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVCeVBpeGVsUmF0aW8oaW5wdXQ6IG51bWJlcikge1xuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihpbnB1dCAqIHBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHVwZGF0ZUtleXdvcmRzKCk7XG4gICAgaW5pdEZyYW1lYnVmZmVycygpO1xuXG4gICAgbGV0IGxhc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgY29sb3JVcGRhdGVUaW1lciA9IDAuMDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lKCkge1xuICAgICAgY29uc3QgZHQgPSBjYWxjRGVsdGFUaW1lKCk7XG4gICAgICBpZiAocmVzaXplQ2FudmFzKCkpIGluaXRGcmFtZWJ1ZmZlcnMoKTtcbiAgICAgIHVwZGF0ZUNvbG9ycyhkdCk7XG4gICAgICBhcHBseUlucHV0cygpO1xuICAgICAgc3RlcChkdCk7XG4gICAgICByZW5kZXIobnVsbCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlRnJhbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNEZWx0YVRpbWUoKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IGR0ID0gKG5vdyAtIGxhc3RVcGRhdGVUaW1lKSAvIDEwMDA7XG4gICAgICBkdCA9IE1hdGgubWluKGR0LCAwLjAxNjY2Nik7XG4gICAgICBsYXN0VXBkYXRlVGltZSA9IG5vdztcbiAgICAgIHJldHVybiBkdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcyEuY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzIS5jbGllbnRIZWlnaHQpO1xuICAgICAgaWYgKGNhbnZhcyEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcyEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzIS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMhLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29sb3JzKGR0OiBudW1iZXIpIHtcbiAgICAgIGNvbG9yVXBkYXRlVGltZXIgKz0gZHQgKiBjb25maWcuQ09MT1JfVVBEQVRFX1NQRUVEO1xuICAgICAgaWYgKGNvbG9yVXBkYXRlVGltZXIgPj0gMSkge1xuICAgICAgICBjb2xvclVwZGF0ZVRpbWVyID0gd3JhcChjb2xvclVwZGF0ZVRpbWVyLCAwLCAxKTtcbiAgICAgICAgcG9pbnRlcnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgIHAuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5SW5wdXRzKCkge1xuICAgICAgZm9yIChjb25zdCBwIG9mIHBvaW50ZXJzKSB7XG4gICAgICAgIGlmIChwLm1vdmVkKSB7XG4gICAgICAgICAgcC5tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgIHNwbGF0UG9pbnRlcihwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoZHQ6IG51bWJlcikge1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIGN1cmxQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmIChjdXJsUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGN1cmxQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJsUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHkpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGN1cmxQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpO1xuICAgICAgfVxuICAgICAgYmxpdChjdXJsKTtcblxuICAgICAgdm9ydGljaXR5UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5KSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICB2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudUN1cmwpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudUN1cmwsIGN1cmwuYXR0YWNoKDEpKTtcbiAgICAgIH1cbiAgICAgIGlmICh2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLmN1cmwpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuY3VybCwgY29uZmlnLkNVUkwpO1xuICAgICAgfVxuICAgICAgaWYgKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuZHQpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuZHQsIGR0KTtcbiAgICAgIH1cbiAgICAgIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICAgICAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gICAgICBkaXZlcmdlbmNlUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAoZGl2ZXJnZW5jZVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplKSB7XG4gICAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgICBkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGl2ZXJnZW5jZVByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5KSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICBkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgICAgICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJsaXQoZGl2ZXJnZW5jZSk7XG5cbiAgICAgIGNsZWFyUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAoY2xlYXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShjbGVhclByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHByZXNzdXJlLnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGVhclByb2dyYW0udW5pZm9ybXMudmFsdWUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy52YWx1ZSwgY29uZmlnLlBSRVNTVVJFKTtcbiAgICAgIH1cbiAgICAgIGJsaXQocHJlc3N1cmUud3JpdGUpO1xuICAgICAgcHJlc3N1cmUuc3dhcCgpO1xuXG4gICAgICBwcmVzc3VyZVByb2dyYW0uYmluZCgpO1xuICAgICAgaWYgKHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnVEaXZlcmdlbmNlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICBwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudURpdmVyZ2VuY2UsXG4gICAgICAgICAgZGl2ZXJnZW5jZS5hdHRhY2goMClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLlBSRVNTVVJFX0lURVJBVElPTlM7IGkrKykge1xuICAgICAgICBpZiAocHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSkge1xuICAgICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICAgIHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51UHJlc3N1cmUsXG4gICAgICAgICAgICBwcmVzc3VyZS5yZWFkLmF0dGFjaCgxKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYmxpdChwcmVzc3VyZS53cml0ZSk7XG4gICAgICAgIHByZXNzdXJlLnN3YXAoKTtcbiAgICAgIH1cblxuICAgICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAoZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSxcbiAgICAgICAgICBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5KSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShcbiAgICAgICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgxKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIGFkdmVjdGlvblByb2dyYW0uYmluZCgpO1xuICAgICAgaWYgKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplKSB7XG4gICAgICAgIGdsLnVuaWZvcm0yZihcbiAgICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nICYmXG4gICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplXG4gICAgICApIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVsb2NpdHlJZCA9IHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApO1xuICAgICAgaWYgKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5KSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHlJZCk7XG4gICAgICB9XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51U291cmNlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UsIHZlbG9jaXR5SWQpO1xuICAgICAgfVxuICAgICAgaWYgKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHQpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHQsIGR0KTtcbiAgICAgIH1cbiAgICAgIGlmIChhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLFxuICAgICAgICAgIGNvbmZpZy5WRUxPQ0lUWV9ESVNTSVBBVElPTlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nICYmXG4gICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplXG4gICAgICApIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplLFxuICAgICAgICAgIGR5ZS50ZXhlbFNpemVYLFxuICAgICAgICAgIGR5ZS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHkpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51U291cmNlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UsIGR5ZS5yZWFkLmF0dGFjaCgxKSk7XG4gICAgICB9XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kaXNzaXBhdGlvbikge1xuICAgICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kaXNzaXBhdGlvbixcbiAgICAgICAgICBjb25maWcuREVOU0lUWV9ESVNTSVBBVElPTlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYmxpdChkeWUud3JpdGUpO1xuICAgICAgZHllLnN3YXAoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIodGFyZ2V0OiBGQk8gfCBudWxsKSB7XG4gICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICBkcmF3RGlzcGxheSh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdEaXNwbGF5KHRhcmdldDogRkJPIHwgbnVsbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSB0YXJnZXQgPyB0YXJnZXQud2lkdGggOiBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0YXJnZXQgPyB0YXJnZXQuaGVpZ2h0IDogZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgICAgIGRpc3BsYXlNYXRlcmlhbC5iaW5kKCk7XG4gICAgICBpZiAoY29uZmlnLlNIQURJTkcgJiYgZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnRleGVsU2l6ZSkge1xuICAgICAgICBnbC51bmlmb3JtMmYoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnRleGVsU2l6ZSwgMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudVRleHR1cmUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy51VGV4dHVyZSwgZHllLnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIH1cbiAgICAgIGJsaXQodGFyZ2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsYXRQb2ludGVyKHBvaW50ZXI6IFBvaW50ZXIpIHtcbiAgICAgIGNvbnN0IGR4ID0gcG9pbnRlci5kZWx0YVggKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gICAgICBjb25zdCBkeSA9IHBvaW50ZXIuZGVsdGFZICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICAgICAgc3BsYXQocG9pbnRlci50ZXhjb29yZFgsIHBvaW50ZXIudGV4Y29vcmRZLCBkeCwgZHksIHBvaW50ZXIuY29sb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaWNrU3BsYXQocG9pbnRlcjogUG9pbnRlcikge1xuICAgICAgY29uc3QgY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICBjb2xvci5yICo9IDEwO1xuICAgICAgY29sb3IuZyAqPSAxMDtcbiAgICAgIGNvbG9yLmIgKj0gMTA7XG4gICAgICBjb25zdCBkeCA9IDEwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgICAgY29uc3QgZHkgPSAzMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICAgIHNwbGF0KHBvaW50ZXIudGV4Y29vcmRYLCBwb2ludGVyLnRleGNvb3JkWSwgZHgsIGR5LCBjb2xvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsYXQoXG4gICAgICB4OiBudW1iZXIsXG4gICAgICB5OiBudW1iZXIsXG4gICAgICBkeDogbnVtYmVyLFxuICAgICAgZHk6IG51bWJlcixcbiAgICAgIGNvbG9yOiBDb2xvclJHQlxuICAgICkge1xuICAgICAgc3BsYXRQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCkge1xuICAgICAgICBnbC51bmlmb3JtMWkoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnVUYXJnZXQsIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMuYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICAgIHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5hc3BlY3RSYXRpbyxcbiAgICAgICAgICBjYW52YXMhLndpZHRoIC8gY2FudmFzIS5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMucG9pbnQpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5wb2ludCwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmNvbG9yKSB7XG4gICAgICAgIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGR4LCBkeSwgMCk7XG4gICAgICB9XG4gICAgICBpZiAoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnJhZGl1cykge1xuICAgICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgICAgc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnJhZGl1cyxcbiAgICAgICAgICBjb3JyZWN0UmFkaXVzKGNvbmZpZy5TUExBVF9SQURJVVMgLyAxMDApIVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCkge1xuICAgICAgICBnbC51bmlmb3JtMWkoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnVUYXJnZXQsIGR5ZS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmNvbG9yKSB7XG4gICAgICAgIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgfVxuICAgICAgYmxpdChkeWUud3JpdGUpO1xuICAgICAgZHllLnN3YXAoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0UmFkaXVzKHJhZGl1czogbnVtYmVyKSB7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGNhbnZhcyEud2lkdGggLyBjYW52YXMhLmhlaWdodDtcbiAgICAgIGlmIChhc3BlY3RSYXRpbyA+IDEpIHJhZGl1cyAqPSBhc3BlY3RSYXRpbztcbiAgICAgIHJldHVybiByYWRpdXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlckRvd25EYXRhKFxuICAgICAgcG9pbnRlcjogUG9pbnRlcixcbiAgICAgIGlkOiBudW1iZXIsXG4gICAgICBwb3NYOiBudW1iZXIsXG4gICAgICBwb3NZOiBudW1iZXJcbiAgICApIHtcbiAgICAgIHBvaW50ZXIuaWQgPSBpZDtcbiAgICAgIHBvaW50ZXIuZG93biA9IHRydWU7XG4gICAgICBwb2ludGVyLm1vdmVkID0gZmFsc2U7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMhLndpZHRoO1xuICAgICAgcG9pbnRlci50ZXhjb29yZFkgPSAxIC0gcG9zWSAvIGNhbnZhcyEuaGVpZ2h0O1xuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgICAgIHBvaW50ZXIuZGVsdGFYID0gMDtcbiAgICAgIHBvaW50ZXIuZGVsdGFZID0gMDtcbiAgICAgIHBvaW50ZXIuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlck1vdmVEYXRhKFxuICAgICAgcG9pbnRlcjogUG9pbnRlcixcbiAgICAgIHBvc1g6IG51bWJlcixcbiAgICAgIHBvc1k6IG51bWJlcixcbiAgICAgIGNvbG9yOiBDb2xvclJHQlxuICAgICkge1xuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcyEud2lkdGg7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEgLSBwb3NZIC8gY2FudmFzIS5oZWlnaHQ7XG4gICAgICBwb2ludGVyLmRlbHRhWCA9IGNvcnJlY3REZWx0YVgoXG4gICAgICAgIHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYXG4gICAgICApITtcbiAgICAgIHBvaW50ZXIuZGVsdGFZID0gY29ycmVjdERlbHRhWShcbiAgICAgICAgcG9pbnRlci50ZXhjb29yZFkgLSBwb2ludGVyLnByZXZUZXhjb29yZFlcbiAgICAgICkhO1xuICAgICAgcG9pbnRlci5tb3ZlZCA9XG4gICAgICAgIE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMDtcbiAgICAgIHBvaW50ZXIuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXI6IFBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXIuZG93biA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3REZWx0YVgoZGVsdGE6IG51bWJlcikge1xuICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYW52YXMhLndpZHRoIC8gY2FudmFzIS5oZWlnaHQ7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBkZWx0YSAqPSBhc3BlY3RSYXRpbztcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0RGVsdGFZKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gY2FudmFzIS53aWR0aCAvIGNhbnZhcyEuaGVpZ2h0O1xuICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMSkgZGVsdGEgLz0gYXNwZWN0UmF0aW87XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcigpOiBDb2xvclJHQiB7XG4gICAgICBjb25zdCBjID0gSFNWdG9SR0IoTWF0aC5yYW5kb20oKSwgMS4wLCAxLjApO1xuICAgICAgYy5yICo9IDAuMTU7XG4gICAgICBjLmcgKj0gMC4xNTtcbiAgICAgIGMuYiAqPSAwLjE1O1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSFNWdG9SR0IoaDogbnVtYmVyLCBzOiBudW1iZXIsIHY6IG51bWJlcik6IENvbG9yUkdCIHtcbiAgICAgIGxldCByID0gMCxcbiAgICAgICAgZyA9IDAsXG4gICAgICAgIGIgPSAwO1xuICAgICAgY29uc3QgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICAgICAgY29uc3QgZiA9IGggKiA2IC0gaTtcbiAgICAgIGNvbnN0IHAgPSB2ICogKDEgLSBzKTtcbiAgICAgIGNvbnN0IHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgICBjb25zdCB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuXG4gICAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gdDtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gcTtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4geyByLCBnLCBiIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgaWYgKHJhbmdlID09PSAwKSByZXR1cm4gbWluO1xuICAgICAgcmV0dXJuICgodmFsdWUgLSBtaW4pICUgcmFuZ2UpICsgbWluO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgICAgdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXIsIC0xLCBwb3NYLCBwb3NZKTtcbiAgICAgIGNsaWNrU3BsYXQocG9pbnRlcik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVGaXJzdE1vdXNlTW92ZShlOiBNb3VzZUV2ZW50KSB7XG4gICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgICAgY29uc3QgY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgICB1cGRhdGVGcmFtZSgpO1xuICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIGNvbG9yKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVGaXJzdE1vdXNlTW92ZSk7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVGaXJzdE1vdXNlTW92ZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgY29uc3QgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WCk7XG4gICAgICBjb25zdCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRZKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gcG9pbnRlci5jb2xvcjtcbiAgICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZLCBjb2xvcik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVGaXJzdFRvdWNoU3RhcnQoZTogVG91Y2hFdmVudCkge1xuICAgICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICAgIHVwZGF0ZUZyYW1lKCk7XG4gICAgICAgIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHBvc1gsIHBvc1kpO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBoYW5kbGVGaXJzdFRvdWNoU3RhcnQpO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZUZpcnN0VG91Y2hTdGFydCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgICAgICBjb25zdCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRZKTtcbiAgICAgICAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgdG91Y2hlc1tpXS5pZGVudGlmaWVyLCBwb3NYLCBwb3NZKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXM7XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WCk7XG4gICAgICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0uY2xpZW50WSk7XG4gICAgICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIHBvaW50ZXIuY29sb3IpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG4gICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlUG9pbnRlclVwRGF0YShwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW1xuICAgIFNJTV9SRVNPTFVUSU9OLFxuICAgIERZRV9SRVNPTFVUSU9OLFxuICAgIENBUFRVUkVfUkVTT0xVVElPTixcbiAgICBERU5TSVRZX0RJU1NJUEFUSU9OLFxuICAgIFZFTE9DSVRZX0RJU1NJUEFUSU9OLFxuICAgIFBSRVNTVVJFLFxuICAgIFBSRVNTVVJFX0lURVJBVElPTlMsXG4gICAgQ1VSTCxcbiAgICBTUExBVF9SQURJVVMsXG4gICAgU1BMQVRfRk9SQ0UsXG4gICAgU0hBRElORyxcbiAgICBDT0xPUl9VUERBVEVfU1BFRUQsXG4gICAgQkFDS19DT0xPUixcbiAgICBUUkFOU1BBUkVOVCxcbiAgXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIHRvcC0wIGxlZnQtMCB6LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgdy1mdWxsIGgtZnVsbFwiPlxuICAgICAgPGNhbnZhc1xuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgaWQ9XCJmbHVpZFwiXG4gICAgICAgIGNsYXNzTmFtZT1cInctc2NyZWVuIGgtc2NyZWVuIGJsb2NrXCJcbiAgICAgID48L2NhbnZhcz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInBvaW50ZXJQcm90b3R5cGUiLCJpZCIsInRleGNvb3JkWCIsInRleGNvb3JkWSIsInByZXZUZXhjb29yZFgiLCJwcmV2VGV4Y29vcmRZIiwiZGVsdGFYIiwiZGVsdGFZIiwiZG93biIsIm1vdmVkIiwiY29sb3IiLCJyIiwiZyIsImIiLCJTcGxhc2hDdXJzb3IiLCJTSU1fUkVTT0xVVElPTiIsIkRZRV9SRVNPTFVUSU9OIiwiQ0FQVFVSRV9SRVNPTFVUSU9OIiwiREVOU0lUWV9ESVNTSVBBVElPTiIsIlZFTE9DSVRZX0RJU1NJUEFUSU9OIiwiUFJFU1NVUkUiLCJQUkVTU1VSRV9JVEVSQVRJT05TIiwiQ1VSTCIsIlNQTEFUX1JBRElVUyIsIlNQTEFUX0ZPUkNFIiwiU0hBRElORyIsIkNPTE9SX1VQREFURV9TUEVFRCIsIkJBQ0tfQ09MT1IiLCJUUkFOU1BBUkVOVCIsImNhbnZhc1JlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJwb2ludGVycyIsImNvbmZpZyIsIlBBVVNFRCIsImdsIiwiZXh0IiwiZ2V0V2ViR0xDb250ZXh0Iiwic3VwcG9ydExpbmVhckZpbHRlcmluZyIsInBhcmFtcyIsImFscGhhIiwiZGVwdGgiLCJzdGVuY2lsIiwiYW50aWFsaWFzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiZ2V0Q29udGV4dCIsIkVycm9yIiwiaXNXZWJHTDIiLCJoYWxmRmxvYXQiLCJnZXRFeHRlbnNpb24iLCJjbGVhckNvbG9yIiwiaGFsZkZsb2F0VGV4VHlwZSIsIkhBTEZfRkxPQVQiLCJIQUxGX0ZMT0FUX09FUyIsImZvcm1hdFJHQkEiLCJmb3JtYXRSRyIsImZvcm1hdFIiLCJnZXRTdXBwb3J0ZWRGb3JtYXQiLCJSR0JBMTZGIiwiUkdCQSIsIlJHMTZGIiwiUkciLCJSMTZGIiwiUkVEIiwiaW50ZXJuYWxGb3JtYXQiLCJmb3JtYXQiLCJ0eXBlIiwic3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQiLCJnbDIiLCJ0ZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJORUFSRVNUIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJ0ZXhJbWFnZTJEIiwiZmJvIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJzdGF0dXMiLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJoYXNoQ29kZSIsInMiLCJsZW5ndGgiLCJoYXNoIiwiaSIsImNoYXJDb2RlQXQiLCJhZGRLZXl3b3JkcyIsInNvdXJjZSIsImtleXdvcmRzIiwia2V5d29yZHNTdHJpbmciLCJrZXl3b3JkIiwiY29tcGlsZVNoYWRlciIsInNoYWRlclNvdXJjZSIsInNoYWRlciIsImNyZWF0ZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiY29uc29sZSIsInRyYWNlIiwiZ2V0U2hhZGVySW5mb0xvZyIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwiZ2V0VW5pZm9ybXMiLCJ1bmlmb3JtcyIsInVuaWZvcm1Db3VudCIsIkFDVElWRV9VTklGT1JNUyIsInVuaWZvcm1JbmZvIiwiZ2V0QWN0aXZlVW5pZm9ybSIsIm5hbWUiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJQcm9ncmFtIiwiYmluZCIsInVzZVByb2dyYW0iLCJjb25zdHJ1Y3RvciIsIk1hdGVyaWFsIiwic2V0S2V5d29yZHMiLCJrdyIsInByb2dyYW1zIiwiRlJBR01FTlRfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJhY3RpdmVQcm9ncmFtIiwiYmFzZVZlcnRleFNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJjb3B5U2hhZGVyIiwiY2xlYXJTaGFkZXIiLCJkaXNwbGF5U2hhZGVyU291cmNlIiwic3BsYXRTaGFkZXIiLCJhZHZlY3Rpb25TaGFkZXIiLCJkaXZlcmdlbmNlU2hhZGVyIiwiY3VybFNoYWRlciIsInZvcnRpY2l0eVNoYWRlciIsInByZXNzdXJlU2hhZGVyIiwiZ3JhZGllbnRTdWJ0cmFjdFNoYWRlciIsImJsaXQiLCJidWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIkZsb2F0MzJBcnJheSIsIlNUQVRJQ19EUkFXIiwiZWxlbUJ1ZmZlciIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiVWludDE2QXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInRhcmdldCIsImRvQ2xlYXIiLCJ2aWV3cG9ydCIsImRyYXdpbmdCdWZmZXJXaWR0aCIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwiZHllIiwidmVsb2NpdHkiLCJkaXZlcmdlbmNlIiwiY3VybCIsInByZXNzdXJlIiwiY29weVByb2dyYW0iLCJjbGVhclByb2dyYW0iLCJzcGxhdFByb2dyYW0iLCJhZHZlY3Rpb25Qcm9ncmFtIiwiZGl2ZXJnZW5jZVByb2dyYW0iLCJjdXJsUHJvZ3JhbSIsInZvcnRpY2l0eVByb2dyYW0iLCJwcmVzc3VyZVByb2dyYW0iLCJncmFkaWVuU3VidHJhY3RQcm9ncmFtIiwiZGlzcGxheU1hdGVyaWFsIiwiY3JlYXRlRkJPIiwidyIsImgiLCJwYXJhbSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInRleGVsU2l6ZVgiLCJ0ZXhlbFNpemVZIiwiYXR0YWNoIiwiY3JlYXRlRG91YmxlRkJPIiwiZmJvMSIsImZibzIiLCJyZWFkIiwid3JpdGUiLCJzd2FwIiwidG1wIiwicmVzaXplRkJPIiwibmV3RkJPIiwidVRleHR1cmUiLCJ1bmlmb3JtMWkiLCJyZXNpemVEb3VibGVGQk8iLCJpbml0RnJhbWVidWZmZXJzIiwic2ltUmVzIiwiZ2V0UmVzb2x1dGlvbiIsImR5ZVJlcyIsInRleFR5cGUiLCJyZ2JhIiwicmciLCJmaWx0ZXJpbmciLCJMSU5FQVIiLCJkaXNhYmxlIiwiQkxFTkQiLCJ1cGRhdGVLZXl3b3JkcyIsImRpc3BsYXlLZXl3b3JkcyIsInB1c2giLCJyZXNvbHV0aW9uIiwiYXNwZWN0UmF0aW8iLCJhc3BlY3QiLCJtaW4iLCJNYXRoIiwicm91bmQiLCJtYXgiLCJzY2FsZUJ5UGl4ZWxSYXRpbyIsImlucHV0IiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJmbG9vciIsImxhc3RVcGRhdGVUaW1lIiwiRGF0ZSIsIm5vdyIsImNvbG9yVXBkYXRlVGltZXIiLCJ1cGRhdGVGcmFtZSIsImR0IiwiY2FsY0RlbHRhVGltZSIsInJlc2l6ZUNhbnZhcyIsInVwZGF0ZUNvbG9ycyIsImFwcGx5SW5wdXRzIiwic3RlcCIsInJlbmRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwid3JhcCIsImZvckVhY2giLCJwIiwiZ2VuZXJhdGVDb2xvciIsInNwbGF0UG9pbnRlciIsInRleGVsU2l6ZSIsInVuaWZvcm0yZiIsInVWZWxvY2l0eSIsInVDdXJsIiwidW5pZm9ybTFmIiwidmFsdWUiLCJ1RGl2ZXJnZW5jZSIsInVQcmVzc3VyZSIsImR5ZVRleGVsU2l6ZSIsInZlbG9jaXR5SWQiLCJ1U291cmNlIiwiZGlzc2lwYXRpb24iLCJibGVuZEZ1bmMiLCJPTkUiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiZW5hYmxlIiwiZHJhd0Rpc3BsYXkiLCJwb2ludGVyIiwiZHgiLCJkeSIsInNwbGF0IiwiY2xpY2tTcGxhdCIsInJhbmRvbSIsIngiLCJ5IiwidVRhcmdldCIsInBvaW50IiwidW5pZm9ybTNmIiwicmFkaXVzIiwiY29ycmVjdFJhZGl1cyIsInVwZGF0ZVBvaW50ZXJEb3duRGF0YSIsInBvc1giLCJwb3NZIiwidXBkYXRlUG9pbnRlck1vdmVEYXRhIiwiY29ycmVjdERlbHRhWCIsImNvcnJlY3REZWx0YVkiLCJhYnMiLCJ1cGRhdGVQb2ludGVyVXBEYXRhIiwiZGVsdGEiLCJjIiwiSFNWdG9SR0IiLCJ2IiwiZiIsInEiLCJ0IiwicmFuZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwiaGFuZGxlRmlyc3RNb3VzZU1vdmUiLCJkb2N1bWVudCIsImJvZHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlRmlyc3RUb3VjaFN0YXJ0IiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJpZGVudGlmaWVyIiwiY2hhbmdlZFRvdWNoZXMiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SplashCursor.tsx\n"));

/***/ })

});